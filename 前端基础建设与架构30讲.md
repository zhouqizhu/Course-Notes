# 1. 理解“前端工程化基建和架构设计”

### 对于业务来说，在工程化基建当中：

- 团队并非一个人单打独斗，那么如何设计工作流程，如何打造一个众人皆赞的项目根基？

- 项目依赖纷繁复杂，如何做好依赖管理和公共库管理？

- 如何深入理解框架，真正做到框架的精通和技术选型的准确拿捏？

- 从最基本的网络请求库说起，如何设计一个稳定灵活的多端 Fetch 库？

- 如何借力 Low Code / No Code 技术，实现越来越智能的应用搭建方案？

- 如何统一中后台项目架构，实现跨业务线的产研效率提升？

- 如何开发设计一套适合业务的组件库，封装分层样式，最大限度做到复用，提升开发效率？

- 如何制定跨端方案，Write Once，Run Everywhere 是否真的可行？

- 如何处理各种模块化规范，以及精确做到代码拆分的最佳实践？

- 如何区分开发边界，比如前端如何更好地利用 Node.js 方案开疆扩土？

前端工程化基建和架构设计：**从项目中的痛点提取基础建设的意义，从个人发展瓶颈总结工程化架构和底层设计**

# 2.  npm 安装机制及企业级部署私服原理

## 1. 安装机制

- Ruby 的 Gem、Python 的 pip 都是全局安装

- npm会优先安装依赖包到当前项目目录，使得不同应用项目的依赖各成体系，同时还减轻了包作者的 API 兼容性压力。但是**同一个依赖包可能在我们的电脑上进行多次安装**  ![](.\img\前端基础建设与架构30讲\Cip5yF_axkqAclTFAAJmlxGYSmI551.png)
  ![](.\img\前端基础建设与架构30讲\Cip5yF_axkqAclTFAAJmlxGYSmI551.png)

## 2. 缓存机制

**对于一个依赖包的同一版本进行本地化缓存，是当代依赖包管理工具的一个常见设计**。

> ```shell
> npm config get cache   // 查看缓存目录 
> npm cache clean --force    // 清除缓存目录中的_cacache文件夹
> ```

当 npm install 执行时，通过[pacote](https://www.npmjs.com/package/pacote "https://www.npmjs.com/package/pacote")把相应的包解压在对应的 node_modules文件夹下面。npm 在下载依赖时，先下载到缓存当中，再解压到项目 node_modules 下。pacote 依赖[npm-registry-fetch](https://github.com/npm/npm-registry-fetch#npm-registry-fetch "https://github.com/npm/npm-registry-fetch#npm-registry-fetch")来下载包，npm-registry-fetch 可以通过设置 cache 属性，在给定的路径下根据[IETF RFC 7234](https://datatracker.ietf.org/doc/rfc7234/ "https://datatracker.ietf.org/doc/rfc7234/")生成缓存数据。

接着，在每次安装资源时，根据 package-lock.json 中存储的 integrity、version、name 信息生成一个唯一的 key，这个 key 能够对应到 index-v5 目录下的缓存记录。如果发现有缓存资源，就会找到 tar 包的 hash，根据 hash 再去找缓存的 tar 包，并再次通过[pacote](https://www.npmjs.com/package/pacote "https://www.npmjs.com/package/pacote")把对应的二进制文件解压到相应的项目 node_modules 下面，省去了网络下载资源的开销。

**常见命令**

- 初始化[npm-init](https://docs.npmjs.com/cli/init "https://docs.npmjs.com/cli/init")
  
  ```shell
  npm init    // 调用 shell 脚本输出一个初始化的 package.json 文件
  ```

- 配置[npm-config](https://docs.npmjs.com/cli-commands/config.html "https://docs.npmjs.com/cli-commands/config.html")
  
  ```shell
  npm config set init.author.name "Lucas"
  npm config set init.author.email "lucasXXXXXX@gmail.com"
  npm config set init.author.url "lucasXXXXX.com"
  npm config set init.license "MIT"
  ```

- 链接[npm-link ](https://docs.npmjs.com/cli/v8/commands/npm-link)
  
  我们先在 package 1 目录中，执行 npm link，这样 npm link 通过链接目录和可执行文件，实现 npm 包命令的全局可执行。
  
  然后在 project 1 中创建链接，执行 npm link npm-package-1 命令时，它就会去 /usr/local/lib/node_modules/ 这个路径下寻找是否有这个包，如果有就建立软链接。

- [npx - npm ](https://www.npmjs.com/package/npx)
  
  可以直接执行 node_modules/.bin 文件夹下的文件。在运行命令时，npx 可以自动去 node_modules/.bin 路径和环境变量 $PATH 里面检查命令是否存在，而不需要再在 package.json 中定义相关的 script。
  
  **npx 执行模块时会优先安装依赖，但是在安装执行后便删除此依赖，这就避免了全局安装模块带来的问题**。

## 3. npm 多源镜像和企业级部署私服原理

npm 中的源（registry），其实就是一个查询服务

可以通过`npm config set`命令来设置安装源或者某个 scope 对应的安装源，很多企业也会搭建自己的 npm 源。

可以通过 npm-preinstall 的钩子，通过 npm 脚本，在安装公共依赖前自动进行源切换（[npm-preinstall ](https://www.npmjs.com/package/npm-preinstall)）

- npm搭建私服原理

现在社区上主要有 3 种工具来搭建 npm 私服：nexus、verdaccio 以及 cnpm。

 nexus 的架构：

![](.\img\前端基础建设与架构30讲\CgqCHl_Tba6AcJj0AAGPl9HW2qg745.png)

- npm 配置作用优先级

- npm 配置作用优先级

![](.\img\前端基础建设与架构30讲\CgqCHl_TbZCAanocAADUyWa5fV4429.png)

# 3. Yarn 的安装理念及如何破解依赖管理困境

## 1. Yarn优点

- **确定性**：通过 yarn.lock 等机制，保证了确定性。即不管安装顺序如何，相同的依赖关系在任何机器和环境下，都可以以相同的方式被安装。（在 npm v5 之前，没有 package-lock.json 机制，只有默认并不会使用的[npm-shrinkwrap.json](https://docs.npmjs.com/cli/shrinkwrap "https://docs.npmjs.com/cli/shrinkwrap")。）

- **采用模块扁平安装模式**：将依赖包的不同版本，按照一定策略，归结为单个版本，以避免创建多个副本造成冗余（npm 目前也有相同的优化）。

- **网络性能更好**：Yarn 采用了请求排队的理念，类似并发连接池，能够更好地利用网络资源；同时引入了更好的安装失败时的重试机制。

- **采用缓存机制，实现了离线模式**（npm 目前也有类似实现）。
  
  yarn.lock 并没有使用 JSON 格式，而是采用了一种自定义的标记格式， yarn.lock 中子依赖的版本号不是固定版本
  
  Yarn 默认使用 prefer-online 模式，即优先使用网络数据。

## 2. 命令

**独有命令**

```shell
yarn import    // 帮助当前依赖项目的迁移
yarn licenses    // 列出已安装依赖的许可证及源码url
yarn pack    // 创建依赖项的压缩gzip
yarn why    // 显示有关为什么安装依赖的信息
yarn autoclean    // 从程序包依赖项中清除并删除不必要的文件
```

npm 独有的命令是：`npm rebuild`。

## 3. 安装机制

![](.\img\前端基础建设与架构30讲\CgqCHl_ZflCANVu8AAJJZZYzwhs026.png)![](.\img\前端基础建设与架构30讲\CgqCHl_ZflCANVu8AAJJZZYzwhs026.png)

- **检测包（checking）**：检测项目中是否存在一些 npm 相关文件

- **解析包（Resolving Packages）**：解析依赖树中每一个包的版本信息。

![](.\img\前端基础建设与架构30讲\CgqCHl_TbimACnDOAAFMC14gP8I289.png)
![](.\img\前端基础建设与架构30讲\CgqCHl_TbimACnDOAAFMC14gP8I289.png)

- **获取包（Fetching Packages）**：首先需要检查缓存中是否存在当前的依赖包，同时将缓存中不存在的依赖包下载到缓存目录

- **链接包（Linking Packages）**：将项目中的依赖复制到项目 node_modules 下，同时遵循扁平化原则。

![](.\img\前端基础建设与架构30讲\Ciqc1F_Tbj2AWiPOAADyaZB-wGw502.png)![](.\img\前端基础建设与架构30讲\Ciqc1F_Tbj2AWiPOAADyaZB-wGw502.png)

- **构建包（Building Packages）**：如果依赖包中存在二进制包需要进行编译，会在这一步进行。

# 4.  CI 环境上的 npm 优化及更多工程化问题解析

## 1. CI 环境上的 npm 优化

- npm ci 和 npm install区别：
  
  - npm ci 要求项目中必须存在 package-lock.json 或 npm-shrinkwrap.json；
  
  - npm ci 完全根据 package-lock.json 安装依赖，这可以保证整个开发团队都使用版本完全一致的依赖；
  
  - npm ci 完全根据 package-lock.json 安装依赖，在安装过程中，它不需要计算求解依赖满足问题、构造依赖树，因此安装过程会更加迅速；
  
  - npm ci 在执行安装时，会先删除项目中现有的 node_modules，然后全新安装；
  
  - npm ci 只能一次安装整个项目所有依赖包，无法安装单个依赖包；
  
  - 如果 package-lock.json 和 package.json 冲突，那么 npm ci 会直接报错，并非更新 lockfiles；
  
  - npm ci 永远不会改变 package.json 和 package-lock.json。
    
    **在 CI 环境使用 npm ci 代替 npm install，一般会获得更加稳定、一致和迅速的安装体验**。
  
  **package-lock.json 中已经缓存了每个包的具体版本和下载链接，你不需要再去远程仓库进行查询，即可直接进入文件完整性校验环节，减少了大量网络请求**。所以使用了 package-lock.json 一般还可以显著加速依赖安装时间。

## 2. 更多工程化相关问题解析

- package-lock.json 文件的作用是锁定依赖安装结构，目的是保证在任意机器上执行 npm install 都会得到完全相同的 node_modules 安装结果。
  
  单一的 package.json 不能确定唯一的依赖树，因为：
  
  - 不同版本的 npm 的安装依赖策略和算法不同；
  
  - npm install 将根据 package.json 中的 semver-range version 更新依赖，某些依赖项自上次安装以来，可能已发布了新版本。
  
  **保证能够完整准确地还原项目依赖**，就是 lockfiles 出现的原因。

- 并不是所有的子依赖都有 dependencies 属性，只有子依赖的依赖和当前已安装在根目录的 node_modules 中的依赖冲突之后，才会有这个属性。

- npm 依赖类型声明：
  
  - dependencies 项目依赖
  
  - devDependencies 开发依赖
  
  - peerDependencies 同版本依赖
  
  - bundledDependencies 捆绑依赖
  
  - optionalDependencies 可选依赖

- 最佳实操：
  
  1. 优先使用 npm v5.4.2 以上的 npm 版本，以保证 npm 的最基本先进性和稳定性。
  
  2. 项目的第一次搭建使用 npm install 安装依赖包，并提交 package.json、package-lock.json，而不提交 node_modules 目录。
  
  3. 其他项目成员首次 checkout/clone 项目代码后，执行一次 npm install 安装依赖包。
  
  4. 对于升级依赖包的需求：
  - 依靠 npm update 命令升级到新的小版本；
  
  - 依靠 npm install @ 升级大版本；
  
  - 也可以手动修改 package.json 中版本号，并执行 npm install 来升级版本；
  
  - 本地验证升级后新版本无问题，提交新的 package.json、package-lock.json 文件。
  5. 对于降级依赖包的需求：执行 npm install @ 命令，验证没问题后，提交新的 package.json、package-lock.json 文件。
  
  6. 删除某些依赖：
  - 执行 npm uninstall 命令，验证没问题后，提交新的 package.json、package-lock.json 文件；
  
  - 或者手动操作 package.json，删除依赖，执行 npm install 命令，验证没问题后，提交新的 package.json、package-lock.json 文件。
  7. 任何团队成员提交 package.json、package-lock.json 更新后，其他成员应该拉取代码后，执行 npm install 更新依赖。
  
  8. 任何时候都不要修改 package-lock.json。
  
  9. 如果 package-lock.json 出现冲突或问题，建议将本地的 package-lock.json 文件删除，引入远程的 package-lock.json 文件和 package.json，再执行 npm install 命令。

# 5. 横向对比主流构建工具，了解构建工具的设计考量

构建工具比对平台：[Overview | Tooling.Report](https://bundlers.tooling.report/)

## 1. 主流构建工具

- Webpack：主要依赖插件和 loader，能力强大，但配置信息较为烦琐。

- Parcel：零配置，开箱即用，但是在功能的集成上相对有限

## 2. 测评方面

- Code Splitting（代码分割）
  
  - 意味着在构建打包时，能够**导出公共模块，避免重复打包**，以及**在页面加载运行时，实现最合理的按需加载策略**。
  
  - **直接决定了前端的静态资源产出情况**，影响着项目应用的性能表现

- Hashing（对打包资源进行版本信息映射）
  
  - hash 反映了项目的构建版本，同一次构建过程中生成的 hash 都是一样的
  
  - chunkhash 会根据入口文件（Entry）进行依赖解析；contenthash 则会根据文件具体内容，生成 hash 值

- Importing Modules（依赖机制）

- Non-JavaScript Resources（对其他非 JavaScript 类型资源导入的支持能力）

- Output Module Formats（是否支持不同的模块格式导出）

- Transformations（资源转换）

# 6. Vite实现

> Vite，一个基于浏览器原生 ES imports 的开发服务器。利用浏览器去解析 imports，在服务器端按需编译返回，完全跳过了打包这个概念，服务器随起随用。同时不仅有 Vue 文件支持，还搞定了热更新，而且热更新的速度不会随着模块增多而变慢。针对生产环境则可以把同一份代码用 Rollup 打包。虽然现在还比较粗糙，但这个方向我觉得是有潜力的，做得好可以彻底解决改一行代码等半天热更新的问题。

Vite 在开发环境下并没有打包和构建过程

## bundleless方案运行原理图

![](.\img\前端基础建设与架构30讲\Cip5yF_ltUqAV2zLAADo9NOnOvk745.png)

![](.\img\前端基础建设与架构30讲\Ciqc1F_ltVCAEgT6AAERxP80SRw964.png)

## bundleless运行总结

Vite 利用浏览器原生支持 ESM 这一特性，省略了对模块的打包，也就不需要生成 bundle，因此初次启动更快，HMR 特性友好。

Vite 开发模式下，通过启动 koa 服务器，在服务端完成模块的改写（比如单文件的解析编译等）和请求处理，实现真正的按需编译。

Vite Server 所有逻辑基本都依赖中间件实现。这些中间件，拦截请求之后，完成了如下内容：

1. 处理 ESM 语法，比如将业务代码中的 import 第三方依赖路径转为浏览器可识别的依赖路径；

2. 对 .ts、.vue 等文件进行即时编译；

3. 对 Sass/Less 的需要预编译的模块进行编译；

4. 和浏览器端建立 socket 连接，实现 HMR。

Vite HMR 实现原理

Vite 的打包命令使用了 Rollup 进行，这里并没有什么特别之处，我们不再展开讲解。而 Vite 的 HMR 特性，主要是围绕着：

* 通过 watcher 监听文件改动

* 通过 server 端编译资源，并推送新模块内容给浏览器
- 浏览器收到新的模块内容，执行框架层面的 rerender/reload

## Vite实现HMR流程图

> HMR 全称 Hot Module Replacement，中文语境通常翻译为模块热更新，它能够在保持页面状态的情况下动态替换资源模块，提供丝滑顺畅的 Web 页面开发体验。

![](.\img\前端基础建设与架构30讲\CgpVE1_ltm6AN8nCAAMSQ8AjILg631.png)

# 7.core-j 及垫片理念

> ECMAScript每年都会出现许多新的API，用社区上提供的一段代码让我们在不兼容新特性的浏览器上使用该特性，这段代码被称为“polyfill”
> 
> [core-js](https://github.com/zloirock/core-js) 是一个 JavaScript 标准库，它包含了 ECMAScript 2021 在内的多项特性的 polyfills，以及 ECMAScript 在 proposals 阶段的特性、WHATWG/W3C 新特性等。因此它是一个现代化前端项目的“标准套件”。它高度模块化，可以选择需要的功能。不污染全局空间。和babel高度集成。

从工程化的角度来说，一个趋于完美的 polyfill 设计应该满足的核心原则是按需加载补丁，这个按需加载主要包括两方面：

* 按照用户终端环境

* 按照业务代码使用情况
